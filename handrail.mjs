import{I,K,chain,curry,curryObjectK,isFunction,isObject,length,map,pipe,reject}from'f-utility';import{Left,Right}from'fantasy-eithers';import{e1,e2}from'entrust';var isEither=function(a){return a&&isObject(a)&&a.fold&&isFunction(a.fold)},guided=curry(function(a,b){return isEither(b)?b:a(b)}),Left$1=Left,GuidedLeft=guided(Left$1),Right$1=Right,GuidedRight=guided(Right$1),plural=function(a){return 1<a.length?'s':''},expectFunctionProps=curry(function(a,b){return new Error(a+': Expected '+b.join(', ')+' to be function'+plural(b)+'.')}),rejectNonFunctions=reject(isFunction),safeRailInputs=pipe(rejectNonFunctions,Object.keys),rail=curry(function(a,b,c){if(null==c)return GuidedLeft(new Error('rail: Expected to be given non-null input.'));var d=safeRailInputs({assertion:a,wrongPath:b});return 0<d.length?GuidedLeft(expectFunctionProps('rail',d)):(a(c)?GuidedRight:pipe(b,GuidedLeft))(c)}),multiRail=curry(function(a,b,c){return chain(rail(a,b),c)}),allPropsAreFunctions=pipe(reject(isFunction),Object.keys,length,function(a){return 0===a}),judgement=curryObjectK(['jury','law','input'],function(a){var b=a.jury,c=a.law,d=a.input,e=a.deliberation;void 0===e&&(e=I);var f=a.pre;void 0===f&&(f=I);var g=a.post;return void 0===g&&(g=I),pipe(c,pipe(f,e,g),b)(d)}),judgeObject=curryObjectK(['jury','law','input'],function(a){var b=a.jury,c=a.law,d=a.input,e=a.pre;void 0===e&&(e=I);var f=a.post;return void 0===f&&(f=I),judgement({deliberation:Object.keys,pre:e,post:f,jury:b,law:c,input:d})}),safeWarn=curry(function(a,b){return judgeObject({deliberation:I,jury:expectFunctionProps(a),law:rejectNonFunctions,input:b})}),internalRailSafety=curryObjectK(['assertion','wrongPath','rightPath'],function(a){return rail(K(allPropsAreFunctions(a)),K(safeWarn('handrail',a)))}),handrail=curry(function(a,b,c,d){return pipe(internalRailSafety({assertion:a,wrongPath:b,rightPath:c}),multiRail(a,b),map(c))(d)}),guideRail=curry(function(a,b,c){var d=a[0],e=a.slice(1),f=d[0],g=d[1];return pipe.apply(void 0,[rail(f,g)].concat(map(function(b){var c=b[0],a=b[1];return multiRail(c,a)},e),[map(b)]))(c)}),ap=e1('ap'),bimap=e2('bimap'),fold=e2('fold'),map$1=map,chain$1=chain;export{map$1 as map,chain$1 as chain,rail as baluster,handrail as balustrade,fold as net,handrail,rail,multiRail,guideRail,ap,isEither,bimap,fold,Left$1 as Left,GuidedLeft,Right$1 as Right,GuidedRight,guided};
